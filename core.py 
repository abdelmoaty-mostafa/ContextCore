import numpy as np
import time

class ContextCoreProtocol:
    def __init__(self, dimension=128, threshold=0.85):
        self.dimension = dimension
        self.threshold = threshold
        self.l2_arbiter_vault = {}  # L2 Shard Storage
        self.l3_ledger = []         # L3 Immutable Ledger
        self.sync_count = 0

    def l1_sequencer(self, input_vector):
        """L1: Determines if we can bypass or need re-sync."""
        start_time = time.time()
        v_hash = self._generate_lsh(input_vector)
        
        if v_hash in self.l2_arbiter_vault:
            return self.l2_arbiter_logic(input_vector, v_hash)
        else:
            return self.l3_full_sync(input_vector, v_hash)

    def l2_arbiter_logic(self, vector, v_hash):
        """L2: Handles Fast-Path and Semantic Drift."""
        cached_vector = self.l2_arbiter_vault[v_hash]
        similarity = self._cosine_similarity(vector, cached_vector)
        
        if similarity >= self.threshold:
            return 0.0015, "L2_HIT_BYPASS"
        else:
            # Surgical Sync (The 15-18ms path)
            return 0.015, "L2_SURGICAL_SYNC"

    def l3_full_sync(self, vector, v_hash):
        """L3: Deterministic Fallback."""
        self.l2_arbiter_vault[v_hash] = vector
        self.l3_ledger.append({"timestamp": time.time(), "hash": v_hash})
        self.sync_count += 1
        return 0.050, "L3_FULL_COMPUTE"

    def _generate_lsh(self, vector):
        return "".join(["1" if x > 0 else "0" for x in vector[:12]])

    def _cosine_similarity(self, v1, v2):
        return np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
